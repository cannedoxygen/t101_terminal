/**
 * p5.js v1.7.0
 * https://p5js.org/
 *
 * This is a minified placeholder version of p5.js for development purposes.
 * In production, you would replace this with the actual p5.js library file.
 * 
 * The complete library can be downloaded from:
 * https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js
 * 
 * This placeholder allows you to test your application without network requests
 * and provides a minimal set of functions to prevent 500 errors.
 */

(function(global, factory) {
    // Define the p5 constructor
    function p5(sketch, node) {
      // Create a minimal p5 instance
      this._setupDone = false;
      this._pixelDensity = 1;
      this._frameRate = 60;
      this._width = 100;
      this._height = 100;
      
      // Setup main canvas
      this.canvas = document.createElement('canvas');
      this.canvas.width = this._width;
      this.canvas.height = this._height;
      this.canvas.style.width = this._width + 'px';
      this.canvas.style.height = this._height + 'px';
      this.canvas.id = 'defaultCanvas0';
      
      // Get context
      this.drawingContext = this.canvas.getContext('2d');
      
      // Append canvas to target element
      if (node) {
        if (typeof node === 'string') {
          node = document.getElementById(node);
        }
        if (node) {
          node.appendChild(this.canvas);
        }
      } else {
        document.body.appendChild(this.canvas);
      }
      
      // Run user sketch
      if (sketch) {
        this._start(sketch);
      }
      
      return this;
    }
    
    // Define prototype methods
    p5.prototype = {
      // Main loop methods
      _start: function(sketch) {
        this._sketch = sketch;
        
        // Bind methods to the instance
        const self = this;
        
        // Define lifecycle methods
        this.setup = function() {
          if (typeof sketch.setup === 'function') {
            sketch.setup.call(self);
          }
          self._setupDone = true;
        };
        
        this.draw = function() {
          if (typeof sketch.draw === 'function') {
            sketch.draw.call(self);
          }
          
          // Request next frame
          if (self._loop) {
            self._requestAnimId = window.requestAnimationFrame(self.draw);
          }
        };
        
        // Bind events
        if (typeof sketch.mousePressed === 'function') {
          this.canvas.addEventListener('mousedown', function(e) {
            sketch.mousePressed.call(self, e);
          });
        }
        
        if (typeof sketch.mouseReleased === 'function') {
          this.canvas.addEventListener('mouseup', function(e) {
            sketch.mouseReleased.call(self, e);
          });
        }
        
        // Start sketch
        this._loop = true;
        this.setup();
        this.draw();
      },
      
      // Canvas methods
      createCanvas: function(w, h) {
        this._width = w || 100;
        this._height = h || 100;
        this.canvas.width = this._width * this._pixelDensity;
        this.canvas.height = this._height * this._pixelDensity;
        this.canvas.style.width = this._width + 'px';
        this.canvas.style.height = this._height + 'px';
        return this;
      },
      
      resizeCanvas: function(w, h) {
        this.createCanvas(w, h);
        return this;
      },
      
      // Drawing methods
      background: function(r, g, b, a) {
        const ctx = this.drawingContext;
        ctx.save();
        ctx.fillStyle = this._colorString(r, g, b, a);
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.restore();
        return this;
      },
      
      fill: function(r, g, b, a) {
        const ctx = this.drawingContext;
        ctx.fillStyle = this._colorString(r, g, b, a);
        return this;
      },
      
      stroke: function(r, g, b, a) {
        const ctx = this.drawingContext;
        ctx.strokeStyle = this._colorString(r, g, b, a);
        return this;
      },
      
      rect: function(x, y, w, h) {
        const ctx = this.drawingContext;
        ctx.beginPath();
        ctx.rect(x, y, w, h);
        ctx.fill();
        ctx.stroke();
        return this;
      },
      
      ellipse: function(x, y, w, h) {
        const ctx = this.drawingContext;
        h = h || w;
        const kappa = 0.5522848;
        const ox = (w / 2) * kappa;
        const oy = (h / 2) * kappa;
        const xe = x + w;
        const ye = y + h;
        const xm = x + w / 2;
        const ym = y + h / 2;
        
        ctx.beginPath();
        ctx.moveTo(x, ym);
        ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
        ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
        ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
        ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        return this;
      },
      
      line: function(x1, y1, x2, y2) {
        const ctx = this.drawingContext;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        return this;
      },
      
      // Utility methods
      frameRate: function(fps) {
        this._frameRate = fps;
        return this;
      },
      
      noLoop: function() {
        this._loop = false;
        return this;
      },
      
      loop: function() {
        this._loop = true;
        this.draw();
        return this;
      },
      
      // Helper methods
      _colorString: function(r, g, b, a) {
        if (g === undefined) {
          return 'rgb(' + r + ',' + r + ',' + r + ')';
        } else if (b === undefined) {
          return 'rgba(' + r + ',' + r + ',' + r + ',' + g + ')';
        } else if (a === undefined) {
          return 'rgb(' + r + ',' + g + ',' + b + ')';
        } else {
          return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
        }
      }
    };
    
    // Audio related functionality (minimal placeholder)
    p5.prototype.AudioContext = window.AudioContext || window.webkitAudioContext;
    
    // FFT placeholder
    p5.FFT = function() {
      this.analyze = function() {
        // Return fake frequency data
        const fakeData = new Uint8Array(128);
        for (let i = 0; i < 128; i++) {
          fakeData[i] = Math.random() * 255;
        }
        return fakeData;
      };
      
      this.waveform = function() {
        // Return fake waveform data
        const fakeData = new Uint8Array(128);
        for (let i = 0; i < 128; i++) {
          fakeData[i] = 128 + Math.sin(i * 0.1) * 127;
        }
        return fakeData;
      };
      
      return this;
    };
    
    // Sound placeholder
    p5.SoundFile = function() {
      this.play = function() { console.log('SoundFile.play() called'); };
      this.stop = function() { console.log('SoundFile.stop() called'); };
      this.pause = function() { console.log('SoundFile.pause() called'); };
      this.loop = function() { console.log('SoundFile.loop() called'); };
      return this;
    };
    
    // Amplitude placeholder
    p5.Amplitude = function() {
      this.getLevel = function() { return Math.random(); };
      return this;
    };
    
    // Assign the constructor to global scope
    global.p5 = p5;
  })(this);
  
  // Create p5 instance immediately if a processing-sketch element exists
  document.addEventListener('DOMContentLoaded', function() {
    console.log('P5.js placeholder loaded. Please replace with actual library in production.');
  });